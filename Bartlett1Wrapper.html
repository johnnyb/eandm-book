<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//RU" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>Using Turing Oracles in Cognitive Models of Problem-Solving</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<!-- xhtml,html --> 
<meta name="src" content="Bartlett1Wrapper.tex" /> 
<meta name="date" content="2014-03-07 11:40:00" /> 
<link rel="stylesheet" type="text/css" href="Bartlett1Wrapper.css" /> 
</head><body 
>
                                                                                   
                                                                                   
       <div class="maketitle">
                                                                                   
                                                                                   
                                                                                   
                                                                                   

<h2 class="titleHead">Using Turing Oracles in Cognitive Models of
Problem-Solving</h2>
 <div class="author" ></div><br />
<div class="date" ></div>
       </div>
<div class="center" 
>
<!--l. 2--><p class="noindent" >
</p><!--l. 2--><p class="noindent" ><span 
class="cmcsc-10x-x-172">J<span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> B<span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span><span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span></span></p></div>
<div class="center" 
>
<!--l. 2--><p class="noindent" >
</p><!--l. 2--><p class="noindent" >The Blyth Institute</p></div>
       <div 
class="abstract" 
>
<div class="center" 
>
<!--l. 4--><p class="noindent" >
</p><!--l. 4--><p class="noindent" ><span 
class="cmbx-10x-x-109">Abstract</span></p></div>

<a 
 id="dx1-2"></a>
<a 
 id="dx1-3"></a>
<a 
 id="dx1-4"></a>
<a 
 id="dx1-5"></a>
                                                                                   
                                                                                   
      <!--l. 9--><p class="indent" >    <span 
class="cmr-10x-x-109">At the core of engineering is human problem-solving. Creating a cognitive</span>
      <span 
class="cmr-10x-x-109">model of the task of problem-solving is helpful for planning and organizing</span>
      <span 
class="cmr-10x-x-109">engineering  tasks.  One  possibility  rarely  considered  in  modeling  cognitive</span>
      <span 
class="cmr-10x-x-109">processes is the use of Turing Oracles. </span><a 
href="#Xcopeland1998"><span 
class="cmr-10x-x-109">Copeland</span></a><span 
class="cmr-10x-x-109">&#x00A0;(</span><a 
href="#Xcopeland1998"><span 
class="cmr-10x-x-109">1998</span></a><span 
class="cmr-10x-x-109">) put forth the possibility</span>
      <span 
class="cmr-10x-x-109">that the mind could be viewed as an oracle machine, but he never applied that</span>
      <span 
class="cmr-10x-x-109">idea practically. Oracles enable the modeling of processes in the mind which</span>
      <span 
class="cmr-10x-x-109">are not computationally based. Using oracles resolves many of the surprising</span>
      <span 
class="cmr-10x-x-109">results of computational problem-solving which arise as a result of the Tractable</span>
      <span 
class="cmr-10x-x-109">Cognition Thesis and similar mechanistic models of the mind. However, as</span>
      <span 
class="cmr-10x-x-109">research into the use of Turing Oracles in problem-solving is new, there are</span>
      <span 
class="cmr-10x-x-109">many methodological issues.</span>
</p>
</div>
       <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Broad Views of Cognition and Their Historic Consequences in Cognitive
Modeling</h3>
<a 
 id="dx1-1001"></a>
<a 
 id="dx1-1002"></a>
<a 
 id="dx1-1003"></a>
<a 
 id="dx1-1004"></a>
<!--l. 19--><p class="noindent" >In the philosophy of mind, three main overarching theories exist concerning how the mind
works&#8212;physicalism, dualism, and emergentism. These are ways of understanding
cognitive processes in their broadest view. Physicalism is the idea that there is
nothing going on in the mind that is not describable through standard physical
processes. There may yet be physical processes not currently understood or even
known, but, in the long run, there should not be anything involved in causal
processes that is not physical and understandable through physics. Some physicalists
allow for the non-reduction of mental states to physical states, or at least an
epistemological reduction, but they are all clear in the closed causality of the physical
(<a 
href="#Xhorgan1994">Horgan</a>,&#x00A0;<a 
href="#Xhorgan1994">1994</a>).
<a 
 id="dx1-1005"></a>
<a 
 id="dx1-1006"></a>
</p><!--l. 23--><p class="indent" >       Dualism is the primary contender for this area.<a 
 id="dx1-1007"></a> Dualism is the idea that the mind
and the body are not equivalent&#8212;that there exists at least some part of human cognition
that is beyond what is describable by physics or using physical entities. It holds that a
reduction of the mind to brain physics does not capture the entirety of what the
mind is doing. It also says that there is a causal element being left out&#8212;that the
mind, while not itself entirely physical, participates in the causal chain of human
action. In other words, it is not a purely passive element but has a causal role
(<a 
href="#Xheart1994">Heart</a>,&#x00A0;<a 
href="#Xheart1994">1994</a>).
                                                                                   
                                                                                   
<a 
 id="dx1-1008"></a>
<a 
 id="dx1-1009"></a>
</p><!--l. 27--><p class="indent" >       A third theory is emergentism. Emergentism tries to split the line between
physicalism and dualism. However, it is a very fluid term and is difficult to distinctly
identify. Some forms of emergentism (especially &#8220;weak emergence&#8221; or &#8220;epistemological
emergence&#8221;) are essentially physicalism, while others (for instance, &#8220;strong emergence&#8221; or
&#8220;ontological emergence&#8221;) propose outside laws of emergence which transform the
character of initial properties in certain configurations (<a 
href="#Xoconnorwong2012">O&#8217;Connor &amp; Wong</a>,&#x00A0;<a 
href="#Xoconnorwong2012">2012</a>).
Therefore, strong emergence tends to be essentially a form of dualism except that the
dualistic properties are captured in a set of laws of emergence. The question then is
whether these laws themselves can be considered material. Since the question
posed in this study concerns whether or not physical causation is sufficient for an
explanation, most views of emergence can be classified as either physicalist or
dualist.
<a 
 id="dx1-1010"></a>
<a 
 id="dx1-1011"></a>
</p><!--l. 31--><p class="indent" >       Historically, aspects of cognition that were considered to be part of the
non-physical mind were left unmodeled by dualists. By contrast, the goal of physicalism
is to force all phenomena into explicitly physical models, a process not easily
accomplished.
</p><!--l. 33--><p class="indent" >       To begin with, defining physicalism and dualism are not easy tasks. For a dualist to
say that there is more than one mode of causation, at least one of those modes needs to be
clearly and explicitly described. Similarly, if a physicalist says that all causes are physical,
such a statement is meaningless without a solid definition of what counts as physical and
what does not (<a 
href="#Xstoljar2009">Stoljar</a>,&#x00A0;<a 
href="#Xstoljar2009">2009</a>).
</p><!--l. 35--><p class="indent" >       Several insufficient definitions of physicalism are often suggested. For example, one
definition is that physicalism deals only with material causes. However, no clear
explanation is given as to what counts as a material cause. Another definition is that
physicalism deals only with observable phenomena. This could have two meanings, both
of which are problematic. If it means that it deals only with things which can
be observed directly, then this would remove most of modern physics from the
physical&#8212;direct observation is not possible for atoms, molecules, forces, and the like. If, on
the other hand, the definition includes indirect observations, then there is no
reason to suppose that only physical entities are observable. It is precisely the
contention of the dualists that there are non-physical modes of causation which have
real effects in the world. If dualism is true, then non-physical causes should be
indirectly observable. Therefore, observability can&#8217;t be a distinguishing factor. A
third definition is that physical things are testable. However, this fails for the
same reason that the observable definition fails. Testing simply means looking at
observations, and determining whether or not they match the expectations of the
theory. Therefore, any observable phenomena should be testable in the same
way.
                                                                                   
                                                                                   
<a 
 id="dx1-1012"></a>
<a 
 id="dx1-1013"></a>
<a 
 id="dx1-1014"></a>
<a 
 id="dx1-1015"></a>
<a 
 id="dx1-1016"></a>
<a 
 id="dx1-1017"></a>
<a 
 id="dx1-1018"></a>
</p><!--l. 44--><p class="indent" >       One distinguishing factor proposed by physicalists to distinguish between physical
and non-physical behavior is computability. With computability, physical processes are
those whose results can (at least in theory) be calculated by computational systems, while
non-physical processes are those which cannot. This has been proposed by Iris
van Rooij in his <span 
class="cmti-12">Tractable Cognition Thesis </span>as well as Stephen Wolfram in his
<span 
class="cmti-12">Principle of Computational Equivalence </span>(<a 
href="#Xvanrooij2008">van Rooij</a>,&#x00A0;<a 
href="#Xvanrooij2008">2008</a>;&#x00A0;<a 
href="#Xwolfram2002">Wolfram</a>,&#x00A0;<a 
href="#Xwolfram2002">2002</a>). By
using this well-defined theory of computability and incomputability, developed
in the early 20th century by Gödel, Church, Turing, and others, it becomes at
least possible to make meaningful statements about physical and non-physical
processes. In addition, because of the groundwork laid by the same pioneers of
computability and incomputability, further advances can be made beyond previous dualist
conceptions of the mind which actually include non-physical elements in models of
cognition.
</p><!--l. 47--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>A Primer on Computability and Incomputability</h3>
<a 
 id="dx1-2001"></a>
<!--l. 50--><p class="noindent" >Incomputability generally refers to the question of whether or not a given function can be
computed given a set of operators. So, for instance, given only the addition, subtraction,
and summation operators, division cannot be computed. However, given those same
operators, a multiplication function can be computed.
<a 
 id="dx1-2002"></a>
</p><!--l. 53--><p class="indent" >       One place where incomputability reigns is on self-referential questions. There are
numerous questions that can be asked about a set of mathematical operators which cannot
be answered solely by the functions of the operators themselves. For example, let&#8217;s say you
have a set of operators (<span 
class="cmmi-12">O</span>) and a list (<span 
class="cmmi-12">L</span>) of all of the valid functions that take a single
value as a parameter, yield a single value as a result, are of finite length, and
can be defined using the operators in <span 
class="cmmi-12">O</span>, listed in alphabetic order. This is a
countable infinity because each function in <span 
class="cmmi-12">L </span>can be identified by an ordinal number,
which is its index into the list. Now, because all of <span 
class="cmmi-12">L </span>are valid functions, there
exists a function <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) which takes the function from <span 
class="cmmi-12">L </span>at index <span 
class="cmmi-12">x </span>and yields
the value of that function with <span 
class="cmmi-12">x </span>as the parameter. The question is, is <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) in
                                                                                   
                                                                                   
<span 
class="cmmi-12">L</span>?
</p><!--l. 55--><p class="indent" >       The answer, perhaps surprisingly, is no. This means that defining <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) will require
operators not in <span 
class="cmmi-12">O</span>. Another example will help demonstrate why. Take another function,
<span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">x</span>), which returns <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) + 1. If <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) is in <span 
class="cmmi-12">L</span>, then, <span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">x</span>) is also in <span 
class="cmmi-12">L </span>(assuming that the
addition operator is in <span 
class="cmmi-12">O</span>). If <span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">x</span>) is at index <span 
class="cmmi-12">n </span>of <span 
class="cmmi-12">L </span>and has a result <span 
class="cmmi-12">r </span>when
computed using its own index (which is defined as <span 
class="cmmi-12">n</span>), by definition, since <span 
class="cmmi-12">n </span>is
the index of <span 
class="cmmi-12">G</span>, then <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">n</span>) must return the same result as <span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">n</span>), which we have
defined to be <span 
class="cmmi-12">r</span>. However, the definition of <span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">x</span>) says that it must be <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) + 1!
Since <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">n</span>) returns <span 
class="cmmi-12">r </span>and <span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">n</span>) returns <span 
class="cmmi-12">r</span>, this leads to a contradiction, because <span 
class="cmmi-12">r</span>
cannot be equal to <span 
class="cmmi-12">r </span>+ 1. Therefore, <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) cannot be computed using the operators
in <span 
class="cmmi-12">O</span>. This proof is quite independent of what operators exist in <span 
class="cmmi-12">O</span>, provided
they are singly valued and include the addition operator. Thus, <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x</span>) is a true
function of <span 
class="cmmi-12">x </span>but is incomputable with fixed-length programs of operators in
<span 
class="cmmi-12">O</span>.
<a 
 id="dx1-2003"></a>
</p><!--l. 58--><p class="indent" >       Using the example given above, it seems that computability questions are based on
the set of operators being used to define it. This is largely true. So, if computability is
operator-dependent, how can it help answer questions about the physicality of the
process? The Church-Turing thesis provides a solution, stating that all finitary
mathematical systems are computationally equivalent to some Turing machine
(<a 
href="#Xturing1937">Turing</a>,&#x00A0;<a 
href="#Xturing1937">1937</a>,&#x00A0;<a 
href="#Xturing1939">1939</a>).<sup><a 
href="#ennote-1" id="enmark-1"><span 
class="cmr-8">1</span></a></sup>
</p>
       <hr class="figure" /><div class="figure" 
>
                                                                                   
                                                                                   
<a 
 id="x1-2004r1"></a>
                                                                                   
                                                                                   

<!--l. 62--><p class="noindent" ><img 
src="TuringMachineDavey.jpg" alt="PIC"  
 />
<br />  </p><div class="caption" 
><span class="id">Figure&#x00A0;1:  </span><span  
class="content">An  example  of  a  working  Turing  machine,  constructed  by  Mike
Davey&#8212;Copyright <span 
class="tcrm-1200">&#x24B8;</span>2012 Rocky Acosta and licensed for reuse under the Created
Commons Attribution License</span></div><!--tex4ht:label?: x1-2004r1 -->
                                                                                   
                                                                                   
       </div><hr class="endfigure" />
<a 
 id="dx1-2005"></a>
<a 
 id="dx1-2006"></a>
<!--l. 68--><p class="indent" >       The Church-Turing thesis was discovered when several finitary logic systems were
developed independently, including Church&#8217;s lambda calculus (<a 
href="#Xchurch1936">Church</a>,&#x00A0;<a 
href="#Xchurch1936">1936</a>;&#x00A0;<a 
href="#Xturing1937">Turing</a>,&#x00A0;<a 
href="#Xturing1937">1937</a>).
It is hard to imagine two systems so different in approach as Church&#8217;s lambda calculus and
the Turing machine. Yet, in the end, it was proven that they have the exact same
computational abilities. To be technically correct, especially with Turing machines, it is
their maximum abilities which are equivalent. A Turing machine can be defined with
equivalent or less computational power than the lambda calculus, but not with
more. Thus, the computational power of finitary systems do imply a fixed set of
operators.
</p><!--l. 70--><p class="indent" >       Such finitary systems which have this maximal computational power are known as
universal machines, or universal computation systems, since they can be programmed
to perform any calculation that is possible on a finitary computation system.
Thus, any computability question that would be true for one of them would be
true for all of them. Therefore, when used without qualification, incomputability
usually refers to something which is incomputable on a universal computation
system.
<a 
 id="dx1-2007"></a>
</p><!--l. 73--><p class="indent" >       Wolfram and van Rooij both use universal computation to set a maximal level of
sophistication available in nature. Wolfram explains his Principle of Computational
Equivalence:
       One might have assumed that among different processes there would
       be  a  vast  range  of  different  levels  of  computational  sophistication.
       But  the  remarkable  assertion  that  the  Principle  of  Computational
       Equivalence makes is that in practice this is not the case, and that
       instead  there  is  essentially  just  one  highest  level  of  computational
       sophistication, and this is achieved by almost all processes that do
       not seem obviously simple&#x00A0;.&#x00A0;.&#x00A0;.&#x00A0;For the essence of this phenomenon
       is that it is possible to construct universal systems that can perform
       essentially any computation&#8212;and which must therefore all in a sense be
       capable of exhibiting the highest level of computational sophistication
       (<a 
href="#Xwolfram2002">Wolfram</a>,&#x00A0;<a 
href="#Xwolfram2002">2002</a>, p.&#x00A0;717).
<a 
 id="dx1-2008"></a>
       Wolfram is thus stating that within nature, computability is the limiting factor of
what is possible. Van Rooij, while restricting his comments to the nature of the mind,
makes basically the same point:
                                                                                   
                                                                                   
       Human   cognitive   capacities   are   constrained   by   computational
       tractability.  This  thesis,  if  true,  serves  cognitive  psychology  by
       constraining the space of computational-level theories of cognition. (<a 
href="#Xvanrooij2008">van
       Rooij</a>,&#x00A0;<a 
href="#Xvanrooij2008">2008</a>, p.&#x00A0;939)
<a 
 id="dx1-2009"></a>
       In other words, if the brain is constrained by computational tractability, then it
limits the possible set of models which could be used when modeling cognition. Van Rooij
specifically traces this back to the idea that the Church-Turing thesis is not merely a
limitation of finitary computation, but is a limitation of reality as a whole, or, as van Rooij
puts it, &#8220;The Church-Turing Thesis is a hypothesis about the state of the world&#8221; (<a 
href="#Xvanrooij2008">van
Rooij</a>,&#x00A0;<a 
href="#Xvanrooij2008">2008</a>, p.&#x00A0;943).
       Wolfram similarly applies his ideas specifically to the brain, saying:
       So  what  about  computations  that  we  perform  abstractly  with
       computers or in our brains? Can these perhaps be more sophisticated?
       Presumably they cannot, at least if we want actual results, and not
       just generalities. For if a computation is to be carried out explicitly,
       then it must ultimately be implemented as a physical process, and
       must therefore be subject to the same limitations as any such process
       (<a 
href="#Xwolfram2002">Wolfram</a>,&#x00A0;<a 
href="#Xwolfram2002">2002</a>, p.&#x00A0;721).
<a 
 id="dx1-2010"></a>
       Thus, physicalism, when defined sufficiently to distinguish it from anything else, has
been defined by its supporters as being equivalent to computationalism. This allows a more
methodical examination of physicalism and dualism to determine which is likely to be
true.
</p>
       <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>The Halting Problem</h3>
<a 
 id="dx1-3001"></a>
<a 
 id="dx1-3002"></a>
<!--l. 102--><p class="noindent" >One of the classic unsolvable problems in computability is the &#8220;halting problem.&#8221; In
universal computation systems, there are ways to cause computations to repeat themselves.
However, this leads to a possible problem&#8212;if a function is poorly written, the
function may get caught in a repetitive portion and not be able to leave. This
computation would be a non-halter, and therefore, left to itself, would never complete.
Most familiar computations are halting computations, as demonstrated in the
following computer program. All programming examples are given in JavaScript for
readability.
                                                                                   
                                                                                   
</p>
       <hr class="figure" /><div class="figure" 
>
                                                                                   
                                                                                   
<a 
 id="x1-3003r2"></a>
                                                                                   
                                                                                   
<div class="verbatim" id="verbatim-1">
function&#x00A0;double(x)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;var&#x00A0;y;
&#x00A0;<br />&#x00A0;&#x00A0;y&#x00A0;=&#x00A0;x&#x00A0;*&#x00A0;2;
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;y;
&#x00A0;<br />}
</div>
<!--l. 112--><p class="nopar" >
<br /> </p><div class="caption" 
><span class="id">Figure&#x00A0;2: </span><span  
class="content">A function to double a value</span></div><!--tex4ht:label?: x1-3003r2 -->
                                                                                   
                                                                                   
       </div><hr class="endfigure" />
<!--l. 117--><p class="indent" >       This program defines a function called <span 
class="cmmi-12">double </span>which obviously doubles its input.
It creates a temporary variable called <span 
class="cmmi-12">y </span>to hold the result of the computation
and then returns <span 
class="cmmi-12">y </span>as the final value for the function. So, after defining it, the
function can be used by saying <span 
class="cmmi-12">double</span>(4) which would give 8, or <span 
class="cmmi-12">double</span>(<span 
class="cmmi-12">z</span>) which
would take the value currently denoted by <span 
class="cmmi-12">z </span>and return whatever is double of
<span 
class="cmmi-12">z</span>.
<a 
 id="dx1-3004"></a>
</p><!--l. 120--><p class="indent" >       The next example will demonstrate the operation of a loop. This program computes
the factorial of a number which is the result of multiplying a number by all of the numbers
below it down to 1. For instance, <span 
class="cmmi-12">factorial</span>(5) is 5 <span 
class="cmsy-10x-x-120">* </span>4 <span 
class="cmsy-10x-x-120">* </span>3 <span 
class="cmsy-10x-x-120">* </span>2 <span 
class="cmsy-10x-x-120">* </span>1. <span 
class="cmmi-12">factorial</span>(3) is
3 <span 
class="cmsy-10x-x-120">* </span>2 <span 
class="cmsy-10x-x-120">* </span>1. So, the number of computations performed, while always finite for a finite
number, varies with the value given. A typical way to program a factorial function
follows:
</p>
       <hr class="figure" /><div class="figure" 
>
                                                                                   
                                                                                   
<a 
 id="x1-3005r3"></a>
                                                                                   
                                                                                   
<div class="verbatim" id="verbatim-2">
function&#x00A0;factorial(x)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;var&#x00A0;val;
&#x00A0;<br />&#x00A0;&#x00A0;var&#x00A0;multiplier;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;val&#x00A0;=&#x00A0;1;
&#x00A0;<br />&#x00A0;&#x00A0;multiplier&#x00A0;=&#x00A0;x;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;while(multiplier&#x00A0;&#x003E;&#x00A0;1)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;val&#x00A0;=&#x00A0;val&#x00A0;*&#x00A0;multiplier;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;multiplier&#x00A0;=&#x00A0;multiplier&#x00A0;-&#x00A0;1;
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;val;
&#x00A0;<br />}
</div>
<!--l. 139--><p class="nopar" >
<br /> </p><div class="caption" 
><span class="id">Figure&#x00A0;3: </span><span  
class="content">A function to compute the factorial of a number</span></div><!--tex4ht:label?: x1-3005r3 -->
                                                                                   
                                                                                   
       </div><hr class="endfigure" />
<!--l. 144--><p class="indent" >       This function defines two temporary variables&#8212;<span 
class="cmmi-12">val</span>, which holds the present state of
the computation, and <span 
class="cmmi-12">multiplier</span>, which holds the next number that needs to be multiplied.
Unlike algebraic systems, in most computer programming languages, variables do not have
static values but can change over the course of the program. The = is not an algebraic
relationship, but rather it means assignment (e.g., <span 
class="cmmi-12">val </span>= 1 means that the value 1 is being
assigned to the variable <span 
class="cmmi-12">val</span>).
</p><!--l. 146--><p class="indent" >       In this program, the value of <span 
class="cmmi-12">multiplier </span>is set to the number given. Then
the computation enters the loop. The <span 
class="cmmi-12">while </span>command tells the computer that
while the value in the <span 
class="cmmi-12">multiplier </span>variable is greater than 1, it should perform the
given computation contained in the curly braces. For example, if the function is
performed with the value of 3, <span 
class="cmmi-12">multiplier </span>will be assigned the value 3, which is greater
than 1. Then the computation within the <span 
class="cmmi-12">while </span>loop will be performed&#8212;it will
multiply <span 
class="cmmi-12">val </span>(which starts off at 1) with <span 
class="cmmi-12">multiplier </span>(which is currently 3), and then
assign that result back into <span 
class="cmmi-12">val</span>. <span 
class="cmmi-12">val </span>now has the number 3. <span 
class="cmmi-12">multiplier </span>is then
decreased by one, and now has the value 2. The bracket indicates the end of
the loop computation, so the condition is re-evaluated. <span 
class="cmmi-12">multiplier</span>&#8217;s value of 2
is still greater than one, so we perform the loop again. <span 
class="cmmi-12">val </span>(which is now 3) is
multiplied by <span 
class="cmmi-12">multiplier </span>(which is now 2) and the value (6) is assigned back
into <span 
class="cmmi-12">val</span>. <span 
class="cmmi-12">multiplier </span>is again decreased and is now 1. Now that the computation
is at the end of the loop, the condition will be evaluated again, and this time
<span 
class="cmmi-12">multiplier </span>is no longer greater than 1. Because the condition is no longer true,
the loop does not run again, and the computation process goes on to the next
statement.
</p><!--l. 148--><p class="indent" >       The next statement returns the value in <span 
class="cmmi-12">val </span>as the result of the entire computation.
Thus, since <span 
class="cmmi-12">val </span>currently holds 6, this function returns 6 as the result of <span 
class="cmmi-12">factorial</span>(3),
which is the correct result. Since it does eventually return a value, it is considered a
halting program. It will take longer to return a value if the input is bigger (since it
has to run the loop computation process more times), and it will return invalid
values if the input is less than one (or not an integer), but it will always return a
value. Therefore, since it will always complete in a finite number of steps, it is a
halter.
</p><!--l. 150--><p class="indent" >       If the programmer writing this function forgot a step (e.g., to write the instruction
that decreases <span 
class="cmmi-12">multiplier</span>), then instead of the previous program, the program might read
as follows:
</p>
       <hr class="figure" /><div class="figure" 
>
                                                                                   
                                                                                   
<a 
 id="x1-3006r4"></a>
                                                                                   
                                                                                   
<div class="verbatim" id="verbatim-3">
function&#x00A0;factorial(x)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;var&#x00A0;val;
&#x00A0;<br />&#x00A0;&#x00A0;var&#x00A0;multiplier;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;val&#x00A0;=&#x00A0;1;
&#x00A0;<br />&#x00A0;&#x00A0;multiplier&#x00A0;=&#x00A0;x;
&#x00A0;<br />&#x00A0;&#x00A0;while(multiplier&#x00A0;&#x003E;&#x00A0;1)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;val&#x00A0;=&#x00A0;val&#x00A0;*&#x00A0;multiplier;
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;val;
&#x00A0;<br />}
</div>
<!--l. 167--><p class="nopar" >
<br /> </p><div class="caption" 
><span class="id">Figure&#x00A0;4: </span><span  
class="content">An incorrect function to compute the factorial of a number</span></div><!--tex4ht:label?: x1-3006r4 -->
                                                                                   
                                                                                   
       </div><hr class="endfigure" />
<a 
 id="dx1-3007"></a>
<!--l. 173--><p class="indent" >       In this example, since <span 
class="cmmi-12">multiplier </span>is never decreased, then, for any input greater than
1, this function will never stop computing! Therefore, in terms of the halting problem, it
doesn&#8217;t halt.
<a 
 id="dx1-3008"></a>
</p><!--l. 176--><p class="indent" >       Functions on universal computation systems are convertible to numbers. In fact,
that&#8217;s how computers work&#8212;the computer stores the program as a very large number. One
example of how this can work is that each character in the above program can be converted
to a fixed-size number and then joined together to a large number to denote the program.
And this is, in fact, how some programming languages function. Most of the time,
however, the conversion of a program into a number actually works by doing a more
intensive conversion of the program into a numeric language that the computer
understands.
</p><!--l. 178--><p class="indent" >       Nonetheless, in each case, the program gets converted into a (usually very large)
number. Therefore, since any program can be converted into a counting number, there are
only a countably infinite number of possible programs. But more importantly, it means
that this program, since it is (or can be represented by) a number, can itself be an input to
a function!
<a 
 id="dx1-3009"></a>
<a 
 id="dx1-3010"></a>
</p><!--l. 182--><p class="indent" >       Some functions halt on certain inputs, but do not halt on other inputs. The
halting question can only be asked on a combination of both the program and the
input since some inputs may halt, and others may not. Therefore, the halting
problem is a function of two variables&#8212;the program <span 
class="cmmi-12">p </span>and the input <span 
class="cmmi-12">i</span>. Every
program/input combination either will halt, or it will not. There is no in-between state
possible on finitary computations. Therefore, <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) can be denoted as a function
which takes the program <span 
class="cmmi-12">p </span>and input <span 
class="cmmi-12">i </span>and gives as a result a 1 if <span 
class="cmmi-12">p</span>(<span 
class="cmmi-12">i</span>) halts,
or a 0 if <span 
class="cmmi-12">p</span>(<span 
class="cmmi-12">i</span>) does not halt. This is known as a &#8220;decision problem&#8221;&#8212;a problem
which takes inputs and decides if the inputs have a particular feature or match
a given pattern. Interestingly, the program <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) cannot be formed using a
universal computation system. This can be proved similarly to the early proof of
incomputability.
</p><!--l. 184--><p class="indent" >       To test this, first it must be assumed that <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) is a program that can be
implemented with a universal computation system. If <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) can be implemented, then it
can also be used by a longer program. A program which does this, <span 
class="cmmi-12">N</span>(<span 
class="cmmi-12">p</span>), is described
below:
</p>
       <hr class="figure" /><div class="figure" 
>
                                                                                   
                                                                                   
<a 
 id="x1-3011r5"></a>
                                                                                   
                                                                                   
<div class="verbatim" id="verbatim-4">
function&#x00A0;N(p)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;if(H(p,&#x00A0;p)&#x00A0;==&#x00A0;1)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;while(1&#x00A0;==&#x00A0;1)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;1;
&#x00A0;<br />}
</div>
<!--l. 197--><p class="nopar" >
<br /> </p><div class="caption" 
><span class="id">Figure&#x00A0;5: </span><span  
class="content">A theoretical function using the halting function which demonstrates its
impossibility</span></div><!--tex4ht:label?: x1-3011r5 -->
                                                                                   
                                                                                   
       </div><hr class="endfigure" />
<!--l. 202--><p class="indent" >       This function starts by evaluating the halting problem of its input, <span 
class="cmmi-12">p</span>, given itself as
the value. If the halting problem of a program <span 
class="cmmi-12">p </span>with itself as the input says &#8220;Yes it
halts&#8221; (i.e., it gives a value of 1), an infinite loop (i.e., a computation which does
not halt) will be performed. If not, the computation should return a value of 1,
completing the computation (i.e., the program will halt with that value). One
can ask the question, does <span 
class="cmmi-12">N</span>(<span 
class="cmmi-12">N</span>) halt? If it does, then this program will loop
forever, but it can&#8217;t, because it has already been determined that it does not
halt! Hence, a contradiction. Likewise the reverse. If <span 
class="cmmi-12">N</span>(<span 
class="cmmi-12">N</span>) does not halt, then
<span 
class="cmmi-12">N</span>(<span 
class="cmmi-12">N</span>) will halt. Therefore, <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) cannot be solved using a universal computation
system.
</p><!--l. 204--><p class="indent" >       This process may seem like an equivocation on the nature of the functions being
described since all of the programs so far have a single input while <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) has two
inputs. However, any number of inputs can be encoded onto a single input using
delimiters. Therefore, specifying multiple inputs is just an easier way to write out the
function than the required steps for encapsulating the inputs together into a single
value.
</p>
       <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-40004"></a>Turing Oracles as Solutions for Incomputable Problems</h3>
<a 
 id="dx1-4001"></a>
<a 
 id="dx1-4002"></a>
<a 
 id="dx1-4003"></a>
<a 
 id="dx1-4004"></a>
<!--l. 213--><p class="noindent" >Turing recognized that although the value of <span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>) was not computable, it was in fact a
true function of its variables&#8212;that is, for every input set, it yielded a single output. Thus,
the halting problem was a hard problem&#8212;it had a solution, but not one that was
determinable through finitary computation. Some important questions arose from this.
Might there be other problems which are harder? Might there be problems which require
the solution to the halting problem to figure out? If so, how does one go about reasoning
about the computational difficulty of an unsolvable problem? The answer is in Turing
Oracles.
</p><!--l. 215--><p class="indent" >       A Turing Oracle (hereafter oracle) is a black-box function (i.e., no implementation
description is given) which solves an incomputable function and yields its answer in a single
step. An oracle machine is a combination of a normal computational system which also has
access to an oracle. If the oracle is well-defined in its abilities, it can be used to
reason about the process even if the process as a whole is incomputable. An oracle
machine, then, is a regular machine (i.e., a normal computable function) which is
connected to an oracle (i.e., the function has access to an operation which is
incomputable).
                                                                                   
                                                                                   
</p><!--l. 217--><p class="indent" >       Alan Turing describes the oracle machine as follows:
</p><!--l. 220--><p class="indent" >
       Let us suppose that we are supplied with some unspecified means of
       solving number theoretic problems; a kind of oracle as it were. We
       will  not  go  any  further  into  the  nature  of  this  oracle  than  to  say
       that it cannot be a machine. With the help of the oracle we could
       form a new kind of machine (call them o-machines), having as one
       of its fundamental processes that of solving a given number theoretic
       problem. (<a 
href="#Xturing1939">Turing</a>,&#x00A0;<a 
href="#Xturing1939">1939</a>, <span 
class="tcrm-1200">§</span>4)
<a 
 id="dx1-4005"></a>
       Even though the values of functions based on oracle machines cannot be computed
(since they are by definition incomputable), it is still possible to reason about which
problems are reducible to oracles and which oracles they are reducible to. Posed another
way, if a programmer had an oracle for a given problem, what other problems could be
solved? For instance, there is an incomputable function called Rado&#8217;s Sigma Function
(affectionately known as the &#8220;busy beaver&#8221; function). This function says, given
<span 
class="cmmi-12">n</span>, what is the longest non-infinite output of any program of size <span 
class="cmmi-12">n</span>? This is an
incomputable function, but it can be shown to be computable given an oracle for
<span 
class="cmmi-12">H</span>(<span 
class="cmmi-12">p,i</span>).
<a 
 id="dx1-4006"></a>
<a 
 id="dx1-4007"></a>
<a 
 id="dx1-4008"></a>
       If dualism is true, then at least some aspects of human cognition are not
computable. However, given the discussion above, even if human cognition is partially
incomputable, cognition may be at least representable if oracles are included in the
allowable set of operations. Several researchers have previously discussed the possibility
that the human mind may be an oracle machine (i.e., <a 
href="#Xcopeland1998">Copeland</a>,&#x00A0;<a 
href="#Xcopeland1998">1998</a>). However, none of
them have suggested including oracles as a standard part of cognitive modeling, or how
one might apply oracles to cognitive modeling (<a 
href="#Xbartlett2010a">Bartlett</a>,&#x00A0;<a 
href="#Xbartlett2010a">2010a</a>,<a 
href="#Xbartlett2010b">b</a>). The goal of
this paper is to present the concept of modeling cognition via oracle machines
and its application to a model of human problem-solving on insight problems.
<a 
 id="dx1-4009"></a>
</p>
       <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-50005"></a>Partial Solutions to Incomputable Functions Using Additional Axioms</h3>
<a 
 id="dx1-5001"></a>
<a 
 id="dx1-5002"></a>
                                                                                   
                                                                                   
<!--l. 237--><p class="noindent" >Incomputable functions are unpredictably sensitive to initial conditions. In other words,
there is no way to computably predict ahead of time the difference in behavior of the
function from the differences in changes to the initial conditions. If this were possible, they
would by definition not be incomputable! However, partial solutions to these functions can
be made by incorporating additional axioms.
</p><!--l. 239--><p class="indent" >       An axiom is a truth that is pre-computational. In other words, it is a truth
about computation rather than a result of computation. Chaitin has shown that
additional axioms can be used to make partial solutions of incomputable functions
(<a 
href="#Xchaitin1982">Chaitin</a>,&#x00A0;<a 
href="#Xchaitin1982">1982</a>). For instance, if God were to say that there are 30 programs less
than size <span 
class="cmmi-12">n </span>that halt for a given programming language, then that fact could
be used to determine exactly which of those programs were the ones that halt.
This is not a complete solution, but rather a partial solution. Nonetheless, it is a
solution larger than what was originally determinable without the additional
axiom.
</p><!--l. 241--><p class="indent" >       Now, most axioms do not come in this form, but instead state that programs that
have a certain pattern of state changes will never halt. This would not generate an
exclusive list, but the list of additional programs that would be known non-halters through
this axiom may be infinitely large. Therefore, by adding axioms, one could potentially be
adding infinite subsets of solutions to incomputable problems. Axiom addition is also by
definition non-algorithmic, for if axioms could be added algorithmically, then the halting
problem would be solvable. Since this is not the case, axiom addition is not an algorithmic
endeavor.
</p><!--l. 243--><p class="indent" >       Once an axiom is known, however, then the computation of halters and non-halters
for which sufficient axioms are known becomes an algorithmic problem. Therefore, the
discovery of new axioms converts subsets of problems from non-algorithmic to algorithmic
forms. <a 
 id="dx1-5003"></a>
</p><!--l. 246--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-60006"></a>Towards Defining a Turing Oracle for Modeling Human Problem-Solving on
Insight Problems</h3>
<a 
 id="dx1-6001"></a>
<a 
 id="dx1-6002"></a>
<a 
 id="dx1-6003"></a>
<a 
 id="dx1-6004"></a>
<!--l. 253--><p class="noindent" >The next step after investigating computability theory is to relate this theory to problems
in cognitive science&#8212;namely problem-solving for insight problems. Cognitive science
usually breaks problem-solving into two broad categories&#8212;analysis problems and insight
problems. Analysis problem are problems which can be solved using a known algorithm or
set of known heuristics and are usually characterized by the subject being aware of how
                                                                                   
                                                                                   
close he is to solving the problem, the benefits of continuous effort, and the use of
pre-existing ideas to solve the problem. Insight problems, on the other hand, are problems
which require a reconceptualization of the process in order to solve them (<a 
href="#Xchronicleetal2004">Chronicle
et&#x00A0;al.</a>,&#x00A0;<a 
href="#Xchronicleetal2004">2004</a>).
<a 
 id="dx1-6005"></a>
</p><!--l. 257--><p class="indent" >       An example of a classic insight problem is the nine-dot problem. In short, the
problem is to take a 3x3 square of dots, and draw four lines that connect every dot without
picking up the pencil. In order to solve the puzzle, the person must realize that the solution
is to extend one of the lines beyond the confines of the box, and make a &#8220;non-dot turn.&#8221;
This reconceptualization of the problem is rare, the subject cannot gauge his
or her own progress, and continuous effort is usually not as helpful as taking
breaks.
<a 
 id="dx1-6006"></a>
</p><!--l. 260--><p class="indent" >       Insight problems like these have significant structural similarity with incomputable
functions. Incomputable functions can be partially solved through adding axioms to the
mix. Axioms function a bit like reconceptualizations&#8212;they allow the problem to be
worked from a different angle using a different approach. Because axioms cannot be
generated algorithmically, it is difficult to conclude how close the solution is.
Likewise, because the person is not following an algorithm (which is impossible for
generating an axiom), continuous effort along the same path is not likely to be
helpful.
<a 
 id="dx1-6007"></a>
</p><!--l. 263--><p class="indent" >       Research on the nine-dot problem has shown that training on certain ideas such as
non-dot turns in similar problems produces an increased success rate in solving the problem
(<a 
href="#Xkershawandohlsson2001">Kershaw &amp; Ohlsson</a>,&#x00A0;<a 
href="#Xkershawandohlsson2001">2001</a>;&#x00A0;<a 
href="#Xkershaw2004">Kershaw</a>,&#x00A0;<a 
href="#Xkershaw2004">2004</a>). This effectively mirrors the way axioms
function in mathematical problem-solving&#8212;by increasing the number of axioms available to
the subject, experimenters were able to greatly reduce the difficulty of the nine-dot problem
for participants.
</p><!--l. 265--><p class="indent" >       Because it is mathematically impossible for a person to take an algorithmic
approach to the general halting problem, it cannot be classed as an analysis problem.
Because of this and its many similarities with other insight problems, the halting problem
should be classified as an insight problem. As such, the discoveries that are made for how
humans solve the halting problem will help formulate more generally a theory of human
insight.
</p><!--l. 267--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x1-70007"></a>Human Solutions to the Halting Problem</h3>
<!--l. 269--><p class="noindent" >As mentioned previously, if humans are able to solve incomputable functions, then the
physicalism hypothesis is false.<sup><a 
href="#ennote-2" id="enmark-2"><span 
class="cmr-8">2</span></a></sup> The halting problem makes a good test case for this idea
                                                                                   
                                                                                   
because it is one of the most widely studied class of incomputable problems on both a
theoretical and a practical level.
</p><!--l. 271--><p class="indent" >       Software development provides the first piece of insight into the process. In software
development, humans have to develop software programs on universal computation
systems, and those programs must halt. If they do not, their programs will be broken.
Therefore, they must solve problems on at least some subset of the halting problem in
order to accomplish their tasks. In addition, the problems that they are given to solve are
not of their own design, so it is not a selection bias. It is simply not true that
programmers are only choosing the programs to solve based on their intrinsic abilities to
solve them because someone else (usually someone without the computational
background needed to know the difference) is assigning the programs. In addition, it is
incorrect to assert that programmers are working around their inabilities to solve
certain types of halting problems, because, while the programmer might add
some extrinsic complexity to a program, the complexity of the problem itself
has an intrinsic minimum complexity regarding a given programming language.
Likewise, simply writing it in another language does not help, because there exists
a finite-sized transformer from any language to any other language, so being
able to solve it in one language is de facto evidence of being able to solve it in
another.
</p><!--l. 273--><p class="indent" >       One may then conclude from the experience of the process of programming that
significant evidence exists that humans are able to at least solve a similar problem to the
halting problem. However, there are some important caveats.
</p><!--l. 275--><p class="indent" >       A minor caveat is that machines in real life do not exhibit true universal
computation as defined in the abstract. Universal computation systems have an infinite
memory and can run forever without breaking down. However, there are two primary
reasons why this is relatively unimportant to this discussion. The first is that even with
fixed-size memory, the halting problem is still practically intractable. That is, the
reason why fixed-size memories allow the halting problem to be solved is that a
programmer could do an exhaustive search of machine states to determine if the
machine state contains cycles (i.e., two exactly equivalent machine states) before
halting. If so, then the program will halt. However, calculating the result of the
halting problem even using finite-sized memory would require either enormous
amounts of time or memory, on the order of 2<sup><span 
class="cmmi-8">n</span></sup>, where n is the number of bits in
memory.<sup><a 
href="#ennote-3" id="enmark-3"><span 
class="cmr-8">3</span></a></sup> In addition, the reasoning usually given by programmers as to why
something should not halt is more similar to a proof than to an exhaustive set of
attempts. If humans are regularly solving the halting problem for a large number of
programs, then it is not because they are being aided by fixed-size computer
memories.
</p><!--l. 277--><p class="indent" >       The main caveat is that there exist programs (even very short programs) for which
humans have not solved the halting problem. Many open problems in number theory can
be quite simply converted into a halting problem so that the answer to the problem can be
solved by knowing whether or not a given computation will halt. If humans have
                                                                                   
                                                                                   
immediate access to a halting problem oracle, why do these programs give such
trouble?
</p><!--l. 279--><p class="indent" >       As an example, a perfect number is a number which is equal to the sum of its
divisors excluding itself. For instance, 6 is a perfect number because 1, 2, and
3 are all divisors, and they add up to 6. It is not known if there are any odd
perfect numbers. A program could be written to search and find an odd perfect
number, and halt if it finds one. Such a program can be fairly simply expressed
as:
</p>
       <hr class="figure" /><div class="figure" 
>
                                                                                   
                                                                                   
<a 
 id="x1-7001r6"></a>
                                                                                   
                                                                                   
<div class="verbatim" id="verbatim-5">
function&#x00A0;odd_perfect_divisor_exists()&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;var&#x00A0;i&#x00A0;=&#x00A0;3;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;while(true)&#x00A0;{&#x00A0;//&#x00A0;This&#x00A0;means&#x00A0;to&#x00A0;loop&#x00A0;forever&#x00A0;unless&#x00A0;terminated
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;//&#x00A0;within&#x00A0;the&#x00A0;loop
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;var&#x00A0;divisors&#x00A0;=&#x00A0;all_divisors_of(i);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;var&#x00A0;divisor_sum&#x00A0;=&#x00A0;sum(divisors);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;if(divisor_sum&#x00A0;==&#x00A0;i)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;i;&#x00A0;//&#x00A0;i.e.&#x00A0;Halt
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;else&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;i&#x00A0;=&#x00A0;i&#x00A0;+&#x00A0;2;&#x00A0;//&#x00A0;Go&#x00A0;to&#x00A0;the&#x00A0;next&#x00A0;odd&#x00A0;number
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />}
</div>
<!--l. 298--><p class="nopar" >
<br /> </p><div class="caption" 
><span class="id">Figure&#x00A0;6: </span><span  
class="content">A function which returns upon finding an odd perfect number</span></div><!--tex4ht:label?: x1-7001r6 -->
                                                                                   
                                                                                   
       </div><hr class="endfigure" />
<!--l. 303--><p class="indent" >       Therefore, if the above program halts, then there is an odd perfect number. If it
does not halt, then there is not one. However, no human currently knows the answer to this
question. Therefore, whatever it is that humans are doing, it is not directly knowing the
answer to the halting problem.
</p><!--l. 305--><p class="indent" >       Will humans ever be able to solve this problem? If humans possessed the same
limitations on computation as computers, then they would never be able to solve this (and
many other) problems. However, math and science, as disciplines, assume that unknown
problems with definite answers will eventually be knowable. Simply stated, the progress of
science depends on the ability of humans to eventually solve such problems as
these.
</p><!--l. 307--><p class="indent" >       In other words, if this is a fundamental limitation of humans, then the search
for more and more mathematical truths may be madness&#8212;they will never be
known. This has led some theorists such as Gregory Chaitin to suppose that
theorists should, in some cases, simply assume the truth or falsity of some claims as
axioms, even in absence of proofs of their truth (<a 
href="#Xchaitin2006">Chaitin</a>,&#x00A0;<a 
href="#Xchaitin2006">2006</a>). This seems to be a
dangerous road to travel. Chaitin uses the fact that different geometries can be made
from different axioms about the nature of the world to justify the arbitrariness of
choosing axioms. In the case of geometry, for instance, the two different answers
to the question of whether parallel lines can intersect generates two different
geometries. However, choosing axiomatic truths for geometry is different than
finding axiomatic truths for solving incomputable problems such as the halting
problem, because in the former the axiom is unconstrained within the system and
in the latter it is constrained but unprovable within the system. If an axiom is
unconstrained, then given the remaining axioms, a fully consistent system can be
maintained with either choice of axiom. In other words, either axiom is equally
consistent with the remaining axioms. If an axiom is constrained but unprovable, then
the truthfulness of an axiom is dependent on the remaining axioms. In other
words, one axiom is true and another is false given the remaining axioms. In the
case of reasoning about the halting problem, programmers are dealing entirely
with constrained but unprovable axioms. It might be a worthwhile endeavor to
provisionally accept an axiom and see where it leads, but it is dangerous to include a
provisionally accepted axiom on equal ground with other types of axioms in formal
mathematics.
</p><!--l. 309--><p class="indent" >       Another option, however, is that humans are able to incrementally arrive at
solutions to halting problems. This would mean that humans have access to an oracle
which is more powerful than finitary computational systems, but less powerful than a
halting oracle.
</p>
                                                                                   
                                                                                   
       <h3 class="sectionHead"><span class="titlemark">8   </span> <a 
 id="x1-80008"></a>An Oracle for Insight Problems</h3>
<a 
 id="dx1-8001"></a>
<!--l. 313--><p class="noindent" >Selmer Bringsjord has argued for the mind being hyper-computational on the basis of his
research into human ability to solve the halting problem. His group claims that they could
always determine the halting problem for Turing machines of size <span 
class="cmmi-12">n </span>if they took into
account the determination of the halting problem for Turing machines of size <span 
class="cmmi-12">n </span><span 
class="cmsy-10x-x-120">- </span>1
(Bringsjord, Kellet, Shilliday, &amp; Taylor, <a 
href="#Xbringsjord2006">2006</a>).
</p><!--l. 315--><p class="indent" >       Bringsjord&#8217;s group has considerable experience with the halting problem, but it is
impossible to tell if his formulation is completely true based on the size of the problem
space when <span 
class="cmmi-12">n </span>goes beyond 4&#8212;there are then too many programs for humans to analyze
(when <span 
class="cmmi-12">n </span>is 5, there are 63,403,380,965,376 programs). What he found, though, is that his
group could formulate halting proofs for programs of size <span 
class="cmmi-12">n </span>based on previous patterns
which were identified for size <span 
class="cmmi-12">n </span><span 
class="cmsy-10x-x-120">- </span>1. They used the proofs that they made for size
<span 
class="cmmi-12">n </span><span 
class="cmsy-10x-x-120">- </span>1 as a basis for the proofs in programs of size <span 
class="cmmi-12">n</span>. This is itself an interesting
result, though it is hard to say that these are necessarily based on program size,
since there is nothing in the halting problem that is program-size dependent. A
better interpretation is that the proofs were built by introducing constrained
axioms. The larger programs utilized the axioms introduced in smaller programs,
but potentially required more axioms to solve. Therefore, the proofs utilized the
smaller programs because they utilized the axioms demonstrated there. As the
programs became larger, the number of axioms required to determine a solution also
grew.
</p><!--l. 317--><p class="indent" >       This explanation actually fits surprisingly well&#8212;it is non-algorithmic (it is
determining unprovable axioms), it is incremental (each axiom gives more explanatory
power), and it is weaker than a halting oracle.
</p><!--l. 319--><p class="indent" >       To put this more formally, let&#8217;s define some values:
</p><!--l. 321--><p class="indent" >
      </p><dl class="description"><dt class="description">
 </dt><dd 
class="description"><span 
class="cmmi-12">A</span>&#8212;the minimum set of axioms required to solve <span 
class="cmmi-12">Q</span>(<span 
class="cmmi-12">p,i</span>)
      </dd><dt class="description">
 </dt><dd 
class="description"><span 
class="cmmi-12">Q</span>&#8212;a decision problem (such as the halting problem)
      </dd><dt class="description">
 </dt><dd 
class="description"><span 
class="cmmi-12">p</span>&#8212;a program
      </dd><dt class="description">
 </dt><dd 
class="description"><span 
class="cmmi-12">i</span>&#8212;the input to program <span 
class="cmmi-12">p</span>
      </dd><dt class="description">
 </dt><dd 
class="description"><span 
class="cmmi-12">B</span>&#8212;a set of axioms such that the size of the set of the intersection of <span 
class="cmmi-12">A </span>and <span 
class="cmmi-12">B </span>is one
      smaller than <span 
class="cmmi-12">A</span>. In other words, <span 
class="cmmi-12">B </span>contains all of the axioms required to solve
      <span 
class="cmmi-12">Q</span>(<span 
class="cmmi-12">p,i</span>) except one.</dd></dl>
                                                                                   
                                                                                   
<!--l. 333--><p class="noindent" >From these definitions human insight can be described by the following oracle:
</p>
       <table 
class="equation"><tr><td><a 
 id="x1-8002r1"></a>
       <center class="math-display" >
<img 
src="Bartlett1Wrapper0x.png" alt="A =  I(Q, p,i,B)
" class="math-display"  /></center></td><td class="equation-label">(1)</td></tr></table>
<!--l. 337--><p class="nopar" >
<a 
 id="dx1-8003"></a>
</p><!--l. 340--><p class="indent" >       In other words, if a human is given a decision problem over a certain input, and he
or she knows all of the axioms needed to solve the problem except one, then human insight
will reveal the remaining axiom. If true, this would explain why insight is both incremental
and non-computational. It goes beyond what is available to computation, but still
has prerequisites. In this proposal, all axioms are known except one. Thus, in
the case of finding odd perfect numbers, the problem of finding the solution to
the problem is that there are not enough pre-existing axioms to infer the final
axiom.
</p><!--l. 342--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">9   </span> <a 
 id="x1-90009"></a>Problems and Directions</h3>
<!--l. 344--><p class="noindent" >The main problem with the description as stated is that there are different kinds of axioms,
yet there is insufficient mathematical theory (at least known to the author) to differentiate
types of axioms. At present, a distinction should be made between bottom-up
and top-down axioms. As mentioned earlier, if God would say that there are
<span 
class="cmmi-12">x </span>halting programs of size <span 
class="cmmi-12">n</span>, a programmer could determine which ones they
were by running all of them simultaneously until <span 
class="cmmi-12">x </span>of them halt. This kind of
axiom, a &#8220;top-down&#8221; axiom, requires prior knowledge of the entire spectrum of the
problem to determine. Another kind of axiom, a &#8220;bottom-up&#8221; axiom, requires a
minimum of understanding in order to be apprehended. Its truth is knowable even if
not provable within its own formalism, and its application is not intrinsically
bounded.
                                                                                   
                                                                                   
<a 
 id="dx1-9001"></a>
<a 
 id="dx1-9002"></a>
<a 
 id="dx1-9003"></a>
<a 
 id="dx1-9004"></a>
</p><!--l. 350--><p class="indent" >       An example of a bottom-up axiom is an axiom which says that if a program has a
loop whose control variable is monotonically decreasing and has a termination condition
which is greater than its start value, then that program will never halt. That
axiom, which is provable by induction, will then allow a programmer to determine
the value of the halting problem for an infinite subset of programs.<sup><a 
href="#ennote-4" id="enmark-4"><span 
class="cmr-8">4</span></a></sup> Thus, it
acts as a bottom-up axiom. In addition, as should be obvious, the introduction
of such an axiom converts an infinite subset of problems from insight problems
to analysis problems. Knowing such axioms allows the programmer to proceed
algorithmically!
</p><!--l. 352--><p class="indent" >       As a result, several open questions emerge:
</p><!--l. 354--><p class="indent" >
      </p><ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-9006x1">Are there other properties of axioms which are important to the sequence in
      which they may be found?
      </li>
      <li 
  class="enumerate" id="x1-9008x2">Are there other prerequisites for finding these axioms?
      </li>
      <li 
  class="enumerate" id="x1-9010x3">In what ways (if any) do axioms relate to program size?
      </li>
      <li 
  class="enumerate" id="x1-9012x4">Is there a proper way to measure the size of an axiom?</li></ol>
<a 
 id="dx1-9013"></a>
<a 
 id="dx1-9014"></a>
<!--l. 363--><p class="indent" >       Chaitin&#8217;s proposal for measuring axioms is related to his &#x03A9; probability. &#x03A9; is the
probability for a given Turing machine as to whether or not it will halt, which, for the sake
of his theory, is written out as a string of bits. Chaitin measures axioms by the number of
bits of &#x03A9; they are able to compute. If an axiom can deduce two bits of &#x03A9;, then the axiom is
two bits long (<a 
href="#Xchaitin2007">Chaitin</a>,&#x00A0;<a 
href="#Xchaitin2007">2007</a>). A naive approach to using this definition might
say that humans are able to deduce a single bit of &#x03A9; when needed. However,
these bits are much &#8220;smaller&#8221; than the types of axioms that humans tend to
develop, which are much wider in extent, as each bit of &#x03A9; is a single program,
rather than a collection of programs. There seems to be, based on experience,
some intrinsic ordering on the discoverability of axioms present within &#x03A9;. An
algorithm can discover 1s (halts) within omega, with an implicit ordering based
on length of program and the program&#8217;s running time. For instance, a program
could be written which started program 1 at time 1, program 2 at time 2, etc.
                                                                                   
                                                                                   
Each iteration would run one cycle of each current program and start one new
program. Each program that halts gives one bit of omega. Therefore, by exhaustive
search, solutions to &#x03A9; can be discovered one bit at a time. However, this does
not match the way humans arrive at the solution, which is a more generalized
axiomatic approach (covering multiple cases of programs at a time&#8212;not just a single
instance like &#x03A9;). Likewise, such algorithms can never discover the 0s (non-halters).
Therefore, although &#x03A9; is a powerful conceptualization of the solution to the halting
problem, it is unlikely to be helpful in the types of axioms that humans appear to be
discovering.
<a 
 id="dx1-9015"></a>
</p><!--l. 366--><p class="indent" >       Another possible way to measure the size of an axiom is to measure the size of the
recognizer function needed to recognize instances of the axiom. But again, it is unclear
whether or not that would be the measurement which would give the proper ordering of
axiom determination. It may be harder to implement a recognizer than it is to intuitively
recognize an axiom.
</p><!--l. 368--><p class="indent" >       Therefore, in order to proceed further, additional research is needed into the nature
of axioms themselves and the different ways that they can be categorized and quantified in
order to find a natural sizing and ordering for them.
</p><!--l. 371--><p class="indent" >       Again, two questions emerge that relate to the embodiment of the oracle
itself:
</p><!--l. 373--><p class="indent" >
      </p><ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-9017x1">How reliable is the axiom-finding oracle?
      </li>
      <li 
  class="enumerate" id="x1-9019x2">What are individual differences in this oracle?</li></ol>
<!--l. 378--><p class="indent" >       The answers to such questions will lead to more understanding about how the oracle
interacts with the rest of the mind&#8217;s systems.
</p><!--l. 380--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">10   </span> <a 
 id="x1-1000010"></a>Generalizing the Oracle Method</h3>
<a 
 id="dx1-10001"></a>
<a 
 id="dx1-10002"></a>
<!--l. 384--><p class="noindent" >Although important, the main focus of this paper is not the specific oracle outlined above.
The larger point is that if an operation in the mind is non-physical, this does not preclude
it from being modeled. Specifically, oracles seem to work for modeling a wide variety of
non-physical operations. There are probably other operations which will require other
formalisms, but formalisms should not be avoided simply because the formalism is not
physically computable.
                                                                                   
                                                                                   
</p><!--l. 386--><p class="indent" >       So how does one make a general application of oracles to modeling the mind? First
of all, it is important that the operation under consideration be well-defined in
terms of what it is doing. It is not worthwhile to simply state &#8220;something occurs
here&#8221;&#8212;such is not a well-specified description. In the example above, specific
preconditions (a decision problem, a program, its input, and a set of existing
axioms) and a specific postcondition (the needed axiom to solve the problem) have
been postulated. William Dembski&#8217;s concept of specification could be used to
determine whether or not the given specification is too broad or if it is reasonably
constraining. Dembski&#8217;s measurement is basically a relationship of the potentially
described target states to the specification length. If a specification does not
sufficiently limit the target space of possibilities, it is not a useful specification
(<a 
href="#Xdembski2005">Dembski</a>,&#x00A0;<a 
href="#Xdembski2005">2005</a>).
</p><!--l. 388--><p class="indent" >       Second, specific reasons must exist in order to believe that the proposed process is
incomputable. Since solving the halting problem is known to be incomputable and adding
axioms is incomputable by definition (otherwise they would be theorems), then specific
evidence indicates that the proposed process is incomputable.
<a 
 id="dx1-10003"></a>
</p><!--l. 391--><p class="indent" >       The hard part then comes in testing the theory. Because the results are
incomputable, and not even likely reducible to a probability distribution, testing it is more
difficult. In the case of computable causes, a specific end-point prediction can be
established by computation, and then the result can be validated against that computation.
In this case, the result is not computable, and therefore validation is more difficult.
Validation will often be based on the qualitative description of the process rather than a
quantitative prediction. Parts of it may still be quantifiable, but only with difficulty. For
instance, to test the example presented, a method of identifying and counting the number
of axioms within a person&#8217;s mind is needed in order to come up with a quantifiable
prediction. However, since this is not possible, it can only be tested based on
secondary quantifications. Thus, testability on proposed oracles becomes much more
dialectic.
</p><!--l. 393--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">11   </span> <a 
 id="x1-1100011"></a>Applications</h3>
<a 
 id="dx1-11001"></a>
<!--l. 396--><p class="noindent" >This method of using oracles for modeling human cognition has many applications to both
psychology and engineering, as well as to the history of technology. For psychology, it
introduces a new way of evaluating mental causes and a new formalism for modeling
and testing them. In several known cases, human problem solving outperforms
what is expected from computationalism. For example, one group of researchers
reported that human performance on the Traveling Salesman Problem scales linearly
                                                                                   
                                                                                   
with the number of nodes, which far surpasses any computational estimator for
the problem (Dry, Lee, Vickers, &amp; Hughes, <a 
href="#Xdryetal2006">2006</a>). Therefore, modeling human
performance in terms of an oracle machine may allow more accurate predictions of
performance.
<a 
 id="dx1-11002"></a>
</p><!--l. 400--><p class="indent" >       For engineering, oracles can be used to better identify and measure complexity. If
axioms become quantifiable, and the number of axioms required to solve problems
becomes quantifiable, then this can transform the practice of complexity estimation.
One such method to use these ideas to calculate software complexity is given in
<a 
href="#Xbartlett2012">Bartlett</a>&#x00A0;(<a 
href="#Xbartlett2012">2014</a>).
<a 
 id="dx1-11003"></a>
<a 
 id="dx1-11004"></a>
</p><!--l. 404--><p class="indent" >       This idea can also be applied to software computer games. Many computer
games are organized by &#8220;levels&#8221; so that each level is harder than the previous one.
One could use axioms as a measure of hardness and construct the levels so that
each one introduces a new axiom used to complete the game. This would allow a
more rigorous approach to game level design at least in certain types of computer
games.
<a 
 id="dx1-11005"></a>
<a 
 id="dx1-11006"></a>
</p><!--l. 408--><p class="indent" >       A final way of using this idea is in understanding the history of technology,
including science and mathematics. It has been a curious feature that many &#8220;leaps&#8221; in
scientific or mathematical thought have been made simultaneously by multiple people.
Isaac Newton and Gottfried Leibniz both independently invented calculus, Gregory Chaitin
and Andrey Kolmogorov both independently invented algorithmic information theory,
Elisha Gray and Alexander Graham Bell both filed a patent for the telephone
on the same day, and the list goes on and on (Aboites, Boltyanskii, &amp; Wilson,
<a 
href="#Xaboitesetal2012">2012</a>).<sup><a 
href="#ennote-5" id="enmark-5"><span 
class="cmr-8">5</span></a></sup> This model, if correct, would validate the view of T. D. Stokes that &#8220;even
though there is no algorithm of discovery, there are logical elements present in the
process whereby a novel hypothesis is devised.&#8221; (<a 
href="#Xstokes1986">Stokes</a>,&#x00A0;<a 
href="#Xstokes1986">1986</a>, p.&#x00A0;111). This
model presents a non-algorithmic process and shows the logical elements which are
within its prerequisites. Therefore, when ideas are widespread, multiple people
will each be a single axiom away from discovery. Consequently, faced with the
same problem, many different people will be able to realize the same missing
axiom.
</p><!--l. 410--><p class="noindent" >
</p>
       <h3 class="sectionHead"><span class="titlemark">12   </span> <a 
 id="x1-1200012"></a>Final Considerations</h3>
<a 
 id="dx1-12001"></a>
                                                                                   
                                                                                   
<a 
 id="dx1-12002"></a>
<a 
 id="dx1-12003"></a>
<!--l. 416--><p class="noindent" >There is good evidence human cognition goes beyond what has been traditionally
considered as &#8220;physical,&#8221; and a lack of physicality does not preclude cognitive modeling.
&#8220;Physical&#8221; has been defined as &#8220;computable&#8221; in order to avoid the ambiguities of the term.
This is important because someone might try to assert that humans have a separate soul
and that it is simply physical. Without a solid definition of what is and is not physical,
nothing prevents such a formulation.
<a 
 id="dx1-12004"></a>
<a 
 id="dx1-12005"></a>
</p><!--l. 420--><p class="indent" >       Roger Penrose and Jack Copeland have both made a similar suggestion
(<a 
href="#Xcopeland1998">Copeland</a>,&#x00A0;<a 
href="#Xcopeland1998">1998</a>;&#x00A0;<a 
href="#Xhodges2000">Hodges</a>,&#x00A0;<a 
href="#Xhodges2000">2000</a>). Both have agreed that humans seem to be oracle
machines, but in a purely physical sense. However, neither of them provided a sufficient
definition of what counted as physical or non-physical to make a proper distinction.
Nothing that either of them has said would contradict what is defended in this paper,
though Penrose argues that there is even more to human consciousness than is
representable through oracle machines&#8212;a position also not in contradiction to the claims
defended here. For instance, it is hard to consider the act of true understanding as a
process involving numbers at all, as John Searle&#8217;s Chinese Room argument shows
(<a 
href="#Xsearle1980">Searle</a>,&#x00A0;<a 
href="#Xsearle1980">1980</a>).
<a 
 id="dx1-12006"></a>
</p><!--l. 423--><p class="indent" >       Another possible objection, then, is to say that the universe as a whole isn&#8217;t
physical. It could be possible, for instance, that even the fundamental laws of matter
are only fully describable using oracles, and none of them at all are computable
with finitary methods, and therefore finitary methods can only be used to solve
certain macro-systems which are the exception rather than the rule. However,
even if true, that would not lead to the conclusion that physicalism is true and
incomputable functions should be classified as physical along with computable ones.
Instead it would reveal that the idealists such as Richard Conn Henry (<a 
href="#Xhenry2005">2005</a>), who
believe that the physical is a mere epiphenomenon and the non-physical is what is
really real, were the ones who were right all along. Douglas Robertson (<a 
href="#Xrobertson1999">1999</a>)
comments:
</p><!--l. 426--><p class="indent" >
       The possibility that phenomena exist that cannot be modeled with
       mathematics  may  throw  an  interesting  light  on  Weinberg&#8217;s  famous
       comment:  &#8220;The  more  the  universe  seems  comprehensible,  the  more
       it seems pointless.&#8221; It might turn out that only that portion of the
       universe that happens to be comprehensible is also pointless.
       In any case, while it is certainly an improbable proposition, it is a logical possibility
that physicalism is not true even for physics!
                                                                                   
                                                                                   
<a 
 id="dx1-12007"></a>
       While the present discussion focuses on models of <span 
class="cmti-12">human </span>insight, that limitation is
purely practical&#8212;there is no known way of detecting or measuring insight behavior on
non-human creatures&#8212;and there is no philosophical, theoretical, or theological reason why
such processes could not be occurring in other creatures at a much lower level. Nothing in
this proposal limits itself either to modeling humans or even organisms. However, in
humans it seems most obvious and evident that restricting reality to only computable
functions is incorrect.
                                                                                   
                                                                                   
</p>
       <h3 class="likesectionHead"><a 
 id="x1-1300012"></a>Notes</h3>
<!--l. 434--><p class="noindent" ></p><!--l. 4--><p class="indent" >       <a 
href="#enmark-1" id="ennote-1"><sup><span 
class="cmr-7">1</span></sup></a><span 
class="cmr-10">Turing machines are important because their functions can be explicitly described and their</span>
<span 
class="cmr-10">operations can be concretely implemented in the real world using machines, and as such they are both</span>
<span 
class="cmr-10">verifiable and unambiguous. A Turing machine consists of four parts&#8212;an (theoretically) infinitely</span>
<span 
class="cmr-10">long tape (i.e., memory), a read/write head for the tape, a state register, and a fixed state transition</span>
<span 
class="cmr-10">table. The only unimplementable feature of Turing machines is the requirement for an infinitely</span>
<span 
class="cmr-10">long tape. However, in the absence of an infinite tape, it can at least be detected when a given</span>
<span 
class="cmr-10">process requires more tape than actually available. One of the purposes of Turing machines was to</span>
<span 
class="cmr-10">make explicit what was meant by the terms &#8220;algorithm,&#8221; &#8220;effectively calculable,&#8221; and &#8220;mechanical</span>
<span 
class="cmr-10">procedure.&#8221; In other words, the original purpose of developing Turing machines was to delineate</span>
<span 
class="cmr-10">between what was calculable and what was not.</span>
</p><!--l. 152--><p class="indent" >       <a 
href="#enmark-2" id="ennote-2"><sup><span 
class="cmr-7">2</span></sup></a><span 
class="cmr-10">Penrose and others have suggested that physical processes are non-computational. However,</span>
<span 
class="cmr-10">they  do  so  without  a  rigorous  definition  of  what  counts  as  &#8220;physical.&#8221;  The  goal  is  to  make</span>
<span 
class="cmr-10">the definition of physical rigorous enough to be testable, and therefore have used computational</span>
<span 
class="cmr-10">tractability as the requirement. See section</span><span 
class="cmr-10">&#x00A0;</span><a 
href="#x1-1200012"><span 
class="cmr-10">12</span><!--tex4ht:ref: sec:final_considerations --></a> <span 
class="cmr-10">for additional discussion.</span>
</p><!--l. 208--><p class="indent" >       <a 
href="#enmark-3" id="ennote-3"><sup><span 
class="cmr-7">3</span></sup></a><span 
class="cmr-10">As an example, one could solve the halting problem on fixed-size memories using a counter</span>
<span 
class="cmr-10">(</span><a 
href="#Xgurari1989"><span 
class="cmr-10">Gurari</span></a><span 
class="cmr-10">,</span><span 
class="cmr-10">&#x00A0;</span><a 
href="#Xgurari1989"><span 
class="cmr-10">1989</span></a><span 
class="cmr-10">). Since the number of possible machine states is 2</span><sup><span 
class="cmmi-7">n</span></sup><span 
class="cmr-10">, then if machine states are counted,</span>
<span 
class="cmr-10">we could determine that it must be a non-halting program if the program performs more than 2</span><sup><span 
class="cmmi-7">n</span></sup>
<span 
class="cmr-10">computations. A faster way of checking for cycles can be implemented, but it would generally require</span>
<span 
class="cmr-10">2</span><sup><span 
class="cmmi-7">n</span></sup> <span 
class="cmr-10">amount of memory.</span>
</p><!--l. 281--><p class="indent" >       <a 
href="#enmark-4" id="ennote-4"><sup><span 
class="cmr-7">4</span></sup></a><span 
class="cmr-10">Some may claim that, since it is proved using an inductive proof, this statement becomes a</span>
<span 
class="cmr-10">theorem rather than an axiom. However, it is only a theorem from second-order logic, since general</span>
<span 
class="cmr-10">induction requires second-order logic and can only be imported to first-order logic as an axiom</span>
<span 
class="cmr-10">(</span><a 
href="#Xenderton2012"><span 
class="cmr-10">Enderton</span></a><span 
class="cmr-10">,</span><span 
class="cmr-10">&#x00A0;</span><a 
href="#Xenderton2012"><span 
class="cmr-10">2012</span></a><span 
class="cmr-10">). Since the machine itself is a first-order logic machine (</span><a 
href="#Xturing1936"><span 
class="cmr-10">Turing</span></a><span 
class="cmr-10">,</span><span 
class="cmr-10">&#x00A0;</span><a 
href="#Xturing1936"><span 
class="cmr-10">1936</span></a><span 
class="cmr-10">), it is an</span>
<span 
class="cmr-10">axiom from the perspective of the first-order system.</span>
</p><!--l. 356--><p class="indent" >       <a 
href="#enmark-5" id="ennote-5"><sup><span 
class="cmr-7">5</span></sup></a><span 
class="cmr-10">Appendix A of </span><a 
href="#Xaboitesetal2012"><span 
class="cmr-10">Aboites et</span><span 
class="cmr-10">&#x00A0;al.</span></a><span 
class="cmr-10">&#x00A0;(</span><a 
href="#Xaboitesetal2012"><span 
class="cmr-10">2012</span></a><span 
class="cmr-10">) contains quite an impressive list of codiscoveries.</span>
                                                                                   
                                                                                   
</p>
       <h3 class="sectionHead"><a 
 id="x1-1400012"></a>References</h3>
  <div class="thebibliography">
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xaboitesetal2012"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>  Aboites,  V.,  Boltyanskii,  V.&#x00A0;G.,  &amp;  Wilson,  M.  (2012).     A  model  for
  co-discovery in science based on the synchronization of gauss maps. <span 
class="cmti-12">International</span>
  <span 
class="cmti-12">Journal  of  Pure  and  Applied  Mathematics</span>,  79(2),  357&#8211;373.    Available  from
  <a 
href="http://ijpam.eu/contents/2012-79-2/15/15.pdf" class="url" >http://ijpam.eu/contents/2012-79-2/15/15.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xbartlett2010a"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Bartlett, J. (2010a). <span 
class="cmti-12">A critique of nonreductive physicalism</span>. Phillips Theological
  Seminary, Tulsa, OK. Unpublished Master&#8217;s Integrative Paper.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xbartlett2010b"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Bartlett, J. (2010b). Developing an approach to non-physical cognitive causation
  in a creation perspective. <span 
class="cmti-12">Occasional Papers of the BSG</span>, 17, 3.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xbartlett2012"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Bartlett, J. (2014).  Calculating software complexity using the halting problem.
  In J. Bartlett, D. Halsmer, &amp; M.&#x00A0;R. Hall (Eds.), <span 
class="cmti-12">Engineering and the ultimate</span>
  (pp.&#x00A0;123&#8211;130). Broken Arrow, OK: Blyth Institute Press.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xbringsjord2006"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>   Bringsjord,   S.,   Kellett,   O.,   Shilliday,   A.,   Taylor,   J.,   van   Heuveln,
  B.,   Yang,   Y.,   Baumes,   J.,   &amp;   Ross,   K.   (2006).       A   new   Gödelian
  argument  for  hypercomputing  minds  based  on  the  busy  beaver  problem.
  <span 
class="cmti-12">Applied  Mathematics  and  Computation</span>,  176(2),  516&#8211;530.      Available  from
  <a 
href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.91.5786\&rep=rep1\&type=pdf" class="url" >http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.91.5786<span 
class="cmsy-10x-x-120">\</span>&amp;rep=rep1<span 
class="cmsy-10x-x-120">\</span>&amp;type=pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xchaitin1982"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>       Chaitin,       G.       (1982).                    Gödel&#8217;s       theorem       and
  information.  <span 
class="cmti-12">International Journal of Theoretical Physics</span>, 21, 941&#8211;954.  Available
  from <a 
href="http://www.cs.auckland.ac.nz/~chaitin/georgia.html" class="url" >http://www.cs.auckland.ac.nz/<span 
class="cmsy-8">~</span>chaitin/georgia.html</a>
  </p>
                                                                                   
                                                                                   
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xchaitin2006"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Chaitin, G. (2006).  The limits of reason.  <span 
class="cmti-12">Scientific American</span>, 294(3), 74&#8211;81.
  Available from <a 
href="http://www.umcs.maine.edu/~chaitin/sciamer3.pdf" class="url" >http://www.umcs.maine.edu/<span 
class="cmsy-8">~</span>chaitin/sciamer3.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xchaitin2007"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Chaitin, G. (2007).  The halting problem omega: Irreducible complexity in pure
  mathematics.   <span 
class="cmti-12">Milan Journal of Mathematics</span>,  75(1),  291&#8211;304.   Available  from
  <a 
href="http://www.cs.auckland.ac.nz/~chaitin/mjm.html" class="url" >http://www.cs.auckland.ac.nz/<span 
class="cmsy-8">~</span>chaitin/mjm.html</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xchronicleetal2004"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>  Chronicle,  E.&#x00A0;P.,  MacGregor,  J.&#x00A0;N.,  &amp;  Ormerod,  T.&#x00A0;C.  (2004).     What
  makes  an  insight  problem?  The  roles  of  heuristics,  goal  conception,  and
  solution   recoding   in   knowledge-lean   problems.      <span 
class="cmti-12">Journal  of  Experimental</span>
  <span 
class="cmti-12">Psychology:  Learning,  Memory,  and  Cognition</span>,  30(1),  14&#8211;27.    Available  from
  <a 
href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.122.5917\&rep=rep1\&type=pdf" class="url" >http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.122.5917<span 
class="cmsy-10x-x-120">\</span>&amp;rep=rep1<span 
class="cmsy-10x-x-120">\</span>&amp;type=pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xchurch1936"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>   Church,   A.   (1936).       An   unsolvable   problem   of   elementary   number
  theory.    <span 
class="cmti-12">American  Journal  of  Mathematics</span>,  58(2),  345&#8211;363.    Available  from
  <a 
href="http://www.jstor.org/stable/2371045" class="url" >http://www.jstor.org/stable/2371045</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcopeland1998"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>    Copeland,    B.&#x00A0;J.    (1998).         Turing&#8217;s    o-machines,    Searle,    Penrose,
  and    the    brain.           <span 
class="cmti-12">Analysis</span>,    58(2),    128&#8211;138.           Available    from
  <a 
href="http://www.hums.canterbury.ac.nz/phil/people/personal\_pages/jack\_copeland/pub/turing1.pdf" class="url" >http://www.hums.canterbury.ac.nz/phil/people/personal<span 
class="cmsy-10x-x-120">\</span>_pages/jack<span 
class="cmsy-10x-x-120">\</span>_copeland/pub/turing1.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xdembski2005"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Dembski, W.&#x00A0;A. (2005).  Specification: The pattern that signifies intelligence.
  <span 
class="cmti-12">Philosophia      Christi</span>,       7(2),       299&#8211;343.                   Available       from
  <a 
href="http://www.designinference.com/documents/2005.06.Specification.pdf" class="url" >http://www.designinference.com/documents/2005.06.Specification.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xdryetal2006"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>   Dry,   M.,   Lee,   M.&#x00A0;D.,   Vickers,   D.,   &amp;   Hughes,   P.   (2006).      Human
  performance  on  visually  presented  traveling  salesperson  problems  with  varying
  numbers  of  nodes.   <span 
class="cmti-12">Journal  of  Problem  Solving</span>,  1(1),  20&#8211;32.   Available  from
  <a 
href="http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1004\&context=jps" class="url" >http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1004<span 
class="cmsy-10x-x-120">\</span>&amp;context=jps</a>
  </p>
                                                                                   
                                                                                   
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xenderton2012"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Enderton, H.&#x00A0;B. (2012). Second-order and higher-order logic. In E. Zalta (Ed.),
  <span 
class="cmti-12">The Stanford encyclopedia of philosophy</span>. The Metaphysics Research Lab, fall 2012
  edition.                                                           Available                    from
  <a 
href="http://plato.stanford.edu/archives/fall2012/entries/logic-higher-order/" class="url" >http://plato.stanford.edu/archives/fall2012/entries/logic-higher-order/</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xgurari1989"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>          Gurari,          E.          (1989).                           <span 
class="cmti-12">An        introduction</span>
  <span 
class="cmti-12">to the theory of computation</span>. New York: Computer Science Press. Available from
  <a 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-twose6.html" class="url" >http://www.cse.ohio-state.edu/<span 
class="cmsy-8">~</span>gurari/theory-bk/theory-bk-twose6.html</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xheart1994"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Heart, W.&#x00A0;D. (1994).  Dualism.  In S. Guttenplan (Ed.), <span 
class="cmti-12">A companion to the</span>
  <span 
class="cmti-12">philosophy of mind </span>(pp.&#x00A0;265&#8211;269). Malden, MA: Wiley-Blackwell.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xhenry2005"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Henry, R.&#x00A0;C. (2005). The mental universe. <span 
class="cmti-12">Nature</span>, 436, 29.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xhodges2000"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Hodges, A. (2000).   Uncomputability in the work of Alan Turing and Roger
  Penrose. Available from <a 
href="http://www.turing.org.uk/philosophy/lecture1.html" class="url" >http://www.turing.org.uk/philosophy/lecture1.html</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xhorgan1994"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Horgan, T. (1994).  Physicalism.  In S. Guttenplan (Ed.), <span 
class="cmti-12">A companion to the</span>
  <span 
class="cmti-12">philosophy of mind </span>(pp.&#x00A0;471&#8211;479). Malden, MA: Wiley-Blackwell.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xkershaw2004"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Kershaw, T.&#x00A0;C. (2004).  Key actions in insight problems: Further evidence for
  the importance of non-dot turns in the nine-dot problem.  In <span 
class="cmti-12">Proceedings of the</span>
  <span 
class="cmti-12">twenty-sixth</span>
  <span 
class="cmti-12">annual conference of the cognitive science society </span>(pp.&#x00A0;678&#8211;683).  Available from
  <a 
href="http://www.cogsci.northwestern.edu/cogsci2004/papers/paper156.pdf" class="url" >http://www.cogsci.northwestern.edu/cogsci2004/papers/paper156.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xkershawandohlsson2001"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>   Kershaw,   T.&#x00A0;C.   &amp;   Ohlsson,   S.   (2001).       Training   for   insight:   The
  case  of  the  nine-dot  problem.     In  <span 
class="cmti-12">Proceedings  of  the  twenty-third  annual</span>
  <span 
class="cmti-12">conference  of  the  cognitive  science  society  </span>(pp.&#x00A0;489&#8211;493).     Available  from
  <a 
href="http://conferences.inf.ed.ac.uk/cogsci2001/pdf-files/0489.pdf" class="url" >http://conferences.inf.ed.ac.uk/cogsci2001/pdf-files/0489.pdf</a>
                                                                                   
                                                                                   
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xoconnorwong2012"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>                    O&#8217;Connor,                    T.                    &amp;                    Wong,
  H.&#x00A0;Y. (2012).  Emergent properties.  In N. Zalta (Ed.), <span 
class="cmti-12">The Stanford encyclopedia</span>
  <span 
class="cmti-12">of philosophy</span>. The Metaphysics Research Lab, spring 2012 edition. Available from
  <a 
href="http://plato.stanford.edu/archives/spr2012/entries/properties-emergent/" class="url" >http://plato.stanford.edu/archives/spr2012/entries/properties-emergent/</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xrobertson1999"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>                         Robertson,                         D.&#x00A0;S.                         (1999).
  Algorithmic information theory, free will, and the Turing test.  <span 
class="cmti-12">Complexity</span>, 4(3),
  25&#8211;34. Available from <a 
href="http://cires.colorado.edu/~doug/philosophy/info8.pdf" class="url" >http://cires.colorado.edu/<span 
class="cmsy-8">~</span>doug/philosophy/info8.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsearle1980"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>         Searle,         J.&#x00A0;R.         (1980).                          Minds,         brains,
  and programs. <span 
class="cmti-12">The Behavioral and Brain Sciences</span>, 3(3), 417&#8211;457. Available from
  <a 
href="http://cogprints.org/7150/1/10.1.1.83.5248.pdf" class="url" >http://cogprints.org/7150/1/10.1.1.83.5248.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xstokes1986"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Stokes, T.&#x00A0;D. (1986).  Reason in the zeitgeist.  <span 
class="cmti-12">History of Science</span>, 24, 111&#8211;123.
  Available from <a 
href="http://adsabs.harvard.edu/full/1986HisSc..24..111S" class="url" >http://adsabs.harvard.edu/full/1986HisSc..24..111S</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xstoljar2009"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Stoljar, D. (2009).  Physicalism.  In E. Zalta (Ed.), <span 
class="cmti-12">The Stanford encyclopedia</span>
  <span 
class="cmti-12">of philsophy</span>. The Metaphysics Research Lab, fall 2009 edition.   Available from
  <a 
href="http://plato.stanford.edu/archives/fall2009/entries/physicalism/" class="url" >http://plato.stanford.edu/archives/fall2009/entries/physicalism/</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xturing1936"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>                                            Turing,                                            A.&#x00A0;M.
  (1936).  On computable numbers, with application to the entscheidungsproblem.
  <span 
class="cmti-12">Proceedings of the London Mathematical Society</span>,  42,  230&#8211;265.   Available  from
  <a 
href="http://www.cs.virginia.edu/~robins/Turing\_Paper\_1936.pdf" class="url" >http://www.cs.virginia.edu/<span 
class="cmsy-8">~</span>robins/Turing<span 
class="cmsy-10x-x-120">\</span>_Paper<span 
class="cmsy-10x-x-120">\</span>_1936.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xturing1937"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Turing, A.&#x00A0;M. (1937). Computability and <span 
class="cmmi-12">&#x03BB;</span>-definability. <span 
class="cmti-12">The Journal of Symbolic</span>
  <span 
class="cmti-12">Logic</span>, 2(4), 153&#8211;163. Available from <a 
href="http://www.jstor.org/stable/2268280" class="url" >http://www.jstor.org/stable/2268280</a>
  </p>
                                                                                   
                                                                                   
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xturing1939"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>    Turing,    A.&#x00A0;M.    (1939).         Systems    of    logic    based    on    ordinals.
  <span 
class="cmti-12">Proceedings   of   the   London   Mathematical   Society</span>,   45.       Available   from
  <a 
href="https://webspace.princeton.edu/users/jedwards/Turing\%20Centennial\%202012/Mudd\%20Archive\%20files/12285\_AC100\_Turing\_1938.pdf" class="url" >https://webspace.princeton.edu/users/jedwards/Turing<span 
class="cmsy-10x-x-120">\</span>%20Centennial<span 
class="cmsy-10x-x-120">\</span>%202012/Mudd<span 
class="cmsy-10x-x-120">\</span>%20Archive<span 
class="cmsy-10x-x-120">\</span>%20files/12285<span 
class="cmsy-10x-x-120">\</span>_AC100<span 
class="cmsy-10x-x-120">\</span>_Turing<span 
class="cmsy-10x-x-120">\</span>_1938.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xvanrooij2008"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>        van        Rooij,        I.        (2008).                       The        tractable
  cognition thesis.  <span 
class="cmti-12">Cognitive Science: A Multidisciplinary Journal</span>, 32(6).  Available
  from <a 
href="http://staff.science.uva.nl/~szymanik/papers/TractableCognition.pdf" class="url" >http://staff.science.uva.nl/<span 
class="cmsy-8">~</span>szymanik/papers/TractableCognition.pdf</a>
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xwolfram2002"></a><span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span> Wolfram, S. (2002). <span 
class="cmti-12">A new kind of science</span>. Champaign: Wolfram Media. Available
  from <a 
href="http://www.wolframscience.com/nksonline/" class="url" >http://www.wolframscience.com/nksonline/</a>
</p>
  </div>
                                                                                   
                                                                                   
        
</body></html> 

                                                                                   


